<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE hibernate-mapping PUBLIC "-//Hibernate/Hibernate Mapping DTD 3.0//EN"
"http://hibernate.sourceforge.net/hibernate-mapping-3.0.dtd">
<!-- 
    Mapping file autogenerated by MyEclipse Persistence Tools
    此为Hibernate的映射配置，手写容易出现错误。
-->
<hibernate-mapping>
	<!-- table为书库表的名称，catalog为数据库名称，形同虚设 -->
    <class name="it.an.bean.Tracehistory" table="tracehistory" catalog="crm_sys">
        <id name="id" type="java.lang.Integer">
        	<!-- 数据库的字段名 -->
            <column name="id" />
            <!-- 自增长，当然还有很多选择 -->
            <generator class="native" />
        </id>
        <!-- 注意了，逆向工程都是生成多对一关系的，性能好。 fetch=select，能在数据查询时，不用自己创建
        	对象封装，能与entity匹配。lazy为懒加载，若为true，则每次查询时，把外键表数据都查询一次啊，
        	造成资源浪费。弱设置为false为延时加载，此时若想得到外键数据，则需要对事物进行处理，具体可查看
        	web.xml
         -->
        <many-to-one name="employee" class="it.an.bean.Employee" fetch="select" lazy="false">
            <column name="employee_id" />
        </many-to-one>
        <many-to-one name="customer" class="it.an.bean.Customer" fetch="select">
            <column name="customer_id" />
        </many-to-one>
        <property name="traceTime" type="java.sql.Timestamp">
            <column name="traceTime" length="19" />
        </property>
        <property name="traceMethod" type="java.lang.String">
            <column name="traceMethod" length="50" />
        </property>
        <property name="content" type="java.lang.String">
            <column name="content" length="200" />
        </property>
        <property name="result" type="java.lang.Integer">
            <column name="result" />
        </property>
    </class>
</hibernate-mapping>
